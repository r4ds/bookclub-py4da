{
  "hash": "e973a527597289ba8b8fe359f4047d5c",
  "result": {
    "markdown": "# 4. NumPy Basics: Arrays and Vectorized Computation\n\n## Learning Objectives\n\n- Learn about NumPy, a package for numerical computing in Python\n- Use NumPy for array-based data: operations, algorithms\n\n## Import NumPy\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np # Recommended standard NumPy convention \n```\n:::\n\n\n## Array-based operations\n* A fast, flexible container for large datasets in Python\n* Stores multiple items of the same type together\n* Can perform operations on whole blocks of data with similar syntax\n\n![Image of an array with 10 length and the first index, 8th element, and indicies denoted by text](https://media.geeksforgeeks.org/wp-content/uploads/CommonArticleDesign1-min.png)\n\n::: {.panel-tabset}\n\n## Create an array\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\narr = np.array([[1.5, -0.1, 3], [0, -3, 6.5]])\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([[ 1.5, -0.1,  3. ],\n       [ 0. , -3. ,  6.5]])\n```\n:::\n:::\n\n\n## Perform operation\nAll of the elements have been multiplied by 10.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\narr * 10\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([[ 15.,  -1.,  30.],\n       [  0., -30.,  65.]])\n```\n:::\n:::\n\n\n:::\n\n* Every array has a `shape` indicating the size of each dimension\n* and a `dtype`, an object describing the data type of the array\n\n::: {.panel-tabset}\n\n## Shape\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\narr.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n(2, 3)\n```\n:::\n:::\n\n\n## dtype\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\narr.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\ndtype('float64')\n```\n:::\n:::\n\n\n:::\n\n### ndarray\n\n* Generic one/multi-dimensional container where all elements are the same type\n* Created using `numpy.array` function\n\n::: {.panel-tabset}\n## 1D\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndata1 = [6, 7.5, 8, 0, 1]\narr1 = np.array(data1)\narr1\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([6. , 7.5, 8. , 0. , 1. ])\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nprint(arr1.ndim)\nprint(arr1.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n(5,)\n```\n:::\n:::\n\n\n## Multi-dimensional\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ndata2 = [[1, 2, 3, 4], [5, 6, 7, 8]]\narr2 = np.array(data2)\narr2\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[1, 2, 3, 4],\n       [5, 6, 7, 8]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nprint(arr2.ndim)\nprint(arr2.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n(2, 4)\n```\n:::\n:::\n\n\n:::\n\n#### Special array creation\n\n* `numpy.zeros` creates an array of zeros with a given length or shape\n* `numpy.ones` creates an array of ones with a given length or shape\n* `numpy.empty` creates an array without initialized values\n* `numpy.arange` creates a range\n* Pass a tuple for the shape to create a higher dimensional array\n\n::: {.panel-tabset}\n\n## Zeros\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nnp.zeros(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])\n```\n:::\n:::\n\n\n## Multi-dimensional\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nnp.zeros((3, 6))\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]])\n```\n:::\n:::\n\n\n:::\n\n::: {.column-margin}\n`numpy.empty` does not return an array of zeros, though it may look like it.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nnp.empty(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([0.])\n```\n:::\n:::\n\n\n:::\n\n[Wes provides a table of array creation functions in the book.](https://wesmckinney.com/book/numpy-basics.html#tbl-table_array_ctor)\n\n#### Data types for ndarrays\n\n* Unless explicitly specified, `numpy.array` tries to infer a good data created arrays. \n* Data type is stored in a special `dtype` metadata object.\n* Can be explict or converted (cast)\n* It is important to care about the general kind of data you’re dealing with.\n\n::: {.panel-tabset}\n## Inferred dtype\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\narr1.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\ndtype('float64')\n```\n:::\n:::\n\n\n## Explicit dtype\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\narr2 = np.array([1, 2, 3], dtype=np.int32)\narr2.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\ndtype('int32')\n```\n:::\n:::\n\n\n## Cast dtype\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfloat_arr = arr1.astype(np.float64)\nfloat_arr.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\ndtype('float64')\n```\n:::\n:::\n\n\n## Cast dtype using another array\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nint_array = arr1.astype(arr2.dtype)\nint_array.dtype\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\ndtype('int32')\n```\n:::\n:::\n\n\n:::\n\n::: {.column-margin}\nCalling `astype` always creates a new array (a copy of the data), even if the new data type is the same as the old data type.\n:::\n\n[Wes provides a table of supported data types in the book.](https://wesmckinney.com/book/numpy-basics.html#tbl-table_array_dtypes)\n\n## Arithmetic with NumPy Arrays\n\n::: {.panel-tabset}\n## Vectorization\n\nBatch operations on data without `for` loops\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\narr = np.array([[1., 2., 3.], [4., 5., 6.]])\narr * arr\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([[ 1.,  4.,  9.],\n       [16., 25., 36.]])\n```\n:::\n:::\n\n\n## Arithmetic operations with scalars \n\nPropagate the scalar argument to each element in the array\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n1 / arr\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([[1.        , 0.5       , 0.33333333],\n       [0.25      , 0.2       , 0.16666667]])\n```\n:::\n:::\n\n\n## Comparisons between arrays\n\nof the same size yield boolean arrays\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\narr2 = np.array([[0., 4., 1.], [7., 2., 12.]])\n\narr2 > arr\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray([[False,  True, False],\n       [ True, False,  True]])\n```\n:::\n:::\n\n\n:::\n\n## Basic Indexing and Slicing\n\n* select a subset of your data or individual elements\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\narr = np.arange(10)\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n::: {.column-margin}\nArray views are on the original data. Data is not copied, and any modifications to the view will be reflected in the source array. If you want a copy of a slice of an ndarray instead of a view, you will need to explicitly copy the array—for example, `arr[5:8].copy()`.\n:::\n\n::: {.panel-tabset}\n\n## select the sixth element\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\narr[5]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n5\n```\n:::\n:::\n\n\n## select sixth through eighth\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\narr[5:8]\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([5, 6, 7])\n```\n:::\n:::\n\n\n## broadcast data\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\narr[5:8] = 12\n```\n:::\n\n\n:::\n\nExample of \"not copied data\"\n\n**Original**\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\narr_slice = arr[5:8]\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])\n```\n:::\n:::\n\n\n**Change values in new array**\n\nNotice that arr is now changed.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\narr_slice[1] = 123\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\narray([  0,   1,   2,   3,   4,  12, 123,  12,   8,   9])\n```\n:::\n:::\n\n\n**Change all values in an array**\n\nThis is done with bare slice `[:]`:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\narr_slice[:] = 64\narr_slice\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\narray([64, 64, 64])\n```\n:::\n:::\n\n\nHigher dimensional arrays have 1D arrays at each index:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\narr2d = np.array([[1,2,3], [4,5,6], [7,8,9]])\narr2d\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n```\n:::\n:::\n\n\nTo slice, can pass a comma-separated list to select individual elements:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\narr2d[0][2]\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n3\n```\n:::\n:::\n\n\n![](https://media.geeksforgeeks.org/wp-content/uploads/Numpy1.jpg)\n\nOmitting indicies will reduce number of dimensions:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\narr2d[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\narray([1, 2, 3])\n```\n:::\n:::\n\n\nCan assign scalar values or arrays:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\narr2d[0] = 9\narr2d\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([[9, 9, 9],\n       [4, 5, 6],\n       [7, 8, 9]])\n```\n:::\n:::\n\n\nOr create an array of the indices. This is like indexing in two steps:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\narr2d = np.array([[1,2,3], [4,5,6], [7,8,9]])\narr2d[1,0]\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n4\n```\n:::\n:::\n\n\n### Indexing with slices\n\nndarrays can be sliced with the same syntax as Python lists:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\narr = np.arange(10)\n\narr[1:6]\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\nThis slices a range of elements (\"select the first row of `arr2d`\"):\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n# arr2d[row, column]\narr2d[:1]\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\narray([[1, 2, 3]])\n```\n:::\n:::\n\n\nCan pass multiple indicies:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\narr2d[:3, :1] # colons keep the dimensions\n# arr2d[0:3, 0] # does not keep the dimensions\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[1],\n       [4],\n       [7]])\n```\n:::\n:::\n\n\n## Boolean Indexing\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nnames = np.array([\"Bob\", \"Joe\", \"Will\", \"Bob\", \"Will\", \"Joe\", \"Joe\"])\nnames\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\narray(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')\n```\n:::\n:::\n\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\ndata = np.array([[4, 7], [0, 2], [-5, 6], [0, 0], [1, 2], [-12, -4], [3, 4]])\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\narray([[  4,   7],\n       [  0,   2],\n       [ -5,   6],\n       [  0,   0],\n       [  1,   2],\n       [-12,  -4],\n       [  3,   4]])\n```\n:::\n:::\n\n\nLike arithmetic operations, comparisons (such as `==`) with arrays are also vectorized. \n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nnames == \"Bob\"\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\narray([ True, False, False,  True, False, False, False])\n```\n:::\n:::\n\n\nThis boolean array can be passed when indexing the array:\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ndata[names == \"Bob\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\narray([[4, 7],\n       [0, 0]])\n```\n:::\n:::\n\n\nSelect from the rows where names == \"Bob\" and index the columns, too:\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ndata[names == \"Bob\", 1:]\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\narray([[7],\n       [0]])\n```\n:::\n:::\n\n\nSelect everything but \"Bob\":\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nnames != \"Bob\" # or ~(names == \"Bob\")\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\narray([False,  True,  True, False,  True,  True,  True])\n```\n:::\n:::\n\n\nUse boolean arithmetic operators like `&` (and) and `|` (or):\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nmask = (names == \"Bob\") | (names == \"Will\")\nmask\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\narray([ True, False,  True,  True,  True, False, False])\n```\n:::\n:::\n\n\n:::{.column-margin}\nSelecting data from an array by boolean indexing and assigning the result to a new variable always creates a copy of the data.\n:::\n\nSetting values with boolean arrays works by substituting the value or values on the righthand side into the locations where the boolean array's values are `True`.\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\ndata[data < 0] = 0\n```\n:::\n\n\nYou can also set whole rows or columns using a one-dimensional boolean array:\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\ndata[names != \"Joe\"] = 7\n```\n:::\n\n\n## Fancy Indexing\n\nA term adopted by NumPy to describe indexing using integer arrays.\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\narr = np.zeros((8, 4)) # 8 × 4 array\n\nfor i in range(8):\n  arr[i] = i\n\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\narray([[0., 0., 0., 0.],\n       [1., 1., 1., 1.],\n       [2., 2., 2., 2.],\n       [3., 3., 3., 3.],\n       [4., 4., 4., 4.],\n       [5., 5., 5., 5.],\n       [6., 6., 6., 6.],\n       [7., 7., 7., 7.]])\n```\n:::\n:::\n\n\nPass a list or ndarray of integers specifying the desired order to subset rows in a particular order:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\narr[[4, 3, 0, 6]]\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\narray([[4., 4., 4., 4.],\n       [3., 3., 3., 3.],\n       [0., 0., 0., 0.],\n       [6., 6., 6., 6.]])\n```\n:::\n:::\n\n\nUse negative indices selects rows from the end:\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\narr[[-3, -5, -7]]\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\narray([[5., 5., 5., 5.],\n       [3., 3., 3., 3.],\n       [1., 1., 1., 1.]])\n```\n:::\n:::\n\n\nPassing multiple index arrays selects a one-dimensional array of elements corresponding to each tuple of indices (go down then across):\n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\narr = np.arange(32).reshape((8, 4))\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15],\n       [16, 17, 18, 19],\n       [20, 21, 22, 23],\n       [24, 25, 26, 27],\n       [28, 29, 30, 31]])\n```\n:::\n:::\n\n\nHere, the elements (1, 0), (5, 3), (7, 1), and (2, 2) are selected.\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\narr[[1, 5, 7, 2], [0, 3, 1, 2]]\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\narray([ 4, 23, 29, 10])\n```\n:::\n:::\n\n\n:::{.column-margin}\nFancy indexing, unlike slicing, always copies the data into a new array when assigning the result to a new variable.\n:::\n\n## Transposing Arrays and Swapping Axes\n\nTransposing is a special form of reshaping using the special `T` attribute:\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\narr = np.arange(15).reshape((3, 5))\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\narr.T\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\narray([[ 0,  5, 10],\n       [ 1,  6, 11],\n       [ 2,  7, 12],\n       [ 3,  8, 13],\n       [ 4,  9, 14]])\n```\n:::\n:::\n\n\n### Matrix multiplication\n\n:::{.panel-tabset}\n## using `T`\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nnp.dot(arr.T, arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\narray([[125, 140, 155, 170, 185],\n       [140, 158, 176, 194, 212],\n       [155, 176, 197, 218, 239],\n       [170, 194, 218, 242, 266],\n       [185, 212, 239, 266, 293]])\n```\n:::\n:::\n\n\n## using `@` infix operator\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\narr.T @ arr\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\narray([[125, 140, 155, 170, 185],\n       [140, 158, 176, 194, 212],\n       [155, 176, 197, 218, 239],\n       [170, 194, 218, 242, 266],\n       [185, 212, 239, 266, 293]])\n```\n:::\n:::\n\n\n:::\n\nndarray has the method `swapaxes`, which takes a pair of axis numbers and switches the indicated axes to rearrange the data:\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\narr = np.array([[0, 1, 0], [1, 2, -2], [6, 3, 2], [-1, 0, -1], [1, 0, 1], [3, 5, 6]])\narr\narr.swapaxes(0, 1)\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\narray([[ 0,  1,  6, -1,  1,  3],\n       [ 1,  2,  3,  0,  0,  5],\n       [ 0, -2,  2, -1,  1,  6]])\n```\n:::\n:::\n\n\n## Pseudorandom Number Generation\n\nThe `numpy.random` module supplements the built-in Python random module with functions for efficiently generating whole arrays of sample values from many kinds of probability distributions.\n\n* Much faster than Python's built-in `random` module\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\nsamples = np.random.standard_normal(size=(4, 4))\nsamples\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\narray([[ 0.17488936,  1.40484911,  0.15183398, -1.02194459],\n       [ 0.69530047,  1.69838274, -0.5782449 , -0.32245913],\n       [ 1.30932161, -0.48999345, -0.13171682,  0.67943756],\n       [-0.12637043, -0.82355441, -0.86697578, -0.06906716]])\n```\n:::\n:::\n\n\nCan use an explicit generator:\n\n* `seed` determines initial state of generator\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\nrng = np.random.default_rng(seed=12345)\ndata = rng.standard_normal((2, 3))\ndata\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\narray([[-1.42382504,  1.26372846, -0.87066174],\n       [-0.25917323, -0.07534331, -0.74088465]])\n```\n:::\n:::\n\n\n[Wes provides a table of NumPy random number generator methods](https://wesmckinney.com/book/numpy-basics.html#tbl-table_numpy_random)\n\n## Universal Functions: Fast Element-Wise Array Functions\n\nA universal function, or ufunc, is a function that performs element-wise operations on data in ndarrays.\n\nMany ufuncs are simple element-wise transformations:\n\n:::{.panel-tabset}\n## unary \nOne array\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\narr = np.arange(10)\nnp.sqrt(arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\narray([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,\n       2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])\n```\n:::\n:::\n\n\n## binary\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\narr1 = rng.standard_normal(10)\narr2 = rng.standard_normal(10)\nnp.maximum(arr1, arr2)\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\narray([ 0.78884434,  0.6488928 ,  0.57585751,  1.39897899,  2.34740965,\n        0.96849691,  0.90291934,  0.90219827, -0.15818926,  0.44948393])\n```\n:::\n:::\n\n\n## multiple\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nremainder, whole_part = np.modf(arr1)\nremainder\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\narray([-0.3677927 ,  0.6488928 ,  0.36105811, -0.95286306,  0.34740965,\n        0.96849691, -0.75938718,  0.90219827, -0.46695317, -0.06068952])\n```\n:::\n:::\n\n\n:::\n\nUse the `out` argument to assign results into an existing array rather than create a new one:\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nout = np.zeros_like(arr)\nnp.add(arr, 1, out=out)\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])\n```\n:::\n:::\n\n\n## Array-Oriented Programming with Arrays\n\nEvaluate the function `sqrt(x^2 + y^2)` across a regular grid of values: use the `numpy.meshgrid` function takes two one-dimensional arrays and produce two two-dimensional matrices corresponding to all pairs of (x, y) in the two arrays:\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\npoints = np.arange(-5, 5, 0.01) # 100 equally spaced points\nxs, ys = np.meshgrid(points, points)\nxs\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\narray([[-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],\n       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],\n       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],\n       ...,\n       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],\n       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99],\n       [-5.  , -4.99, -4.98, ...,  4.97,  4.98,  4.99]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nys\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\narray([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],\n       [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],\n       [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],\n       ...,\n       [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],\n       [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],\n       [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])\n```\n:::\n:::\n\n\nEvaluate the function as if it were two points:\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\nz = np.sqrt(xs ** 2 + ys ** 2)\nz\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```\narray([[7.07106781, 7.06400028, 7.05693985, ..., 7.04988652, 7.05693985,\n        7.06400028],\n       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,\n        7.05692568],\n       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,\n        7.04985815],\n       ...,\n       [7.04988652, 7.04279774, 7.03571603, ..., 7.0286414 , 7.03571603,\n        7.04279774],\n       [7.05693985, 7.04985815, 7.04278354, ..., 7.03571603, 7.04278354,\n        7.04985815],\n       [7.06400028, 7.05692568, 7.04985815, ..., 7.04279774, 7.04985815,\n        7.05692568]])\n```\n:::\n:::\n\n\n### Bonus: matplotlib visualization\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nplt.imshow(z, cmap=plt.cm.gray)  #, extent=[-25, 10, -10, 10])\nplt.colorbar() \nplt.title(\"Image plot of $\\sqrt{x^2 + y^2}$ for a grid of values\")\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\nText(0.5, 1.0, 'Image plot of $\\\\sqrt{x^2 + y^2}$ for a grid of values')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](04_main_files\\figure-html/cell-64-output-2.png){width=478 height=433}\n:::\n:::\n\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\nplt.close(\"all\")\n```\n:::\n\n\n## Expressing Conditional Logic as Array Operations\n\nThe `numpy.where` function is a vectorized version of the ternary expression `x if condition else`.\n\n* second and third arguments to `numpy.where` can also be scalars\n* can also combine scalars and arrays\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\nxarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])\nyarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])\ncond = np.array([True, False, True, True, False])\n```\n:::\n\n\nTake a value from `xarr` whenever the corresponding value in `cond` is `True`, and otherwise take the value from `yarr`:\n\n:::{.panel-tabset}\n\n## `x if condition else`\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\nresult = [(x if c else y)\n  for x, y, c in zip(xarr, yarr, cond)]\n  \nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\n[1.1, 2.2, 1.3, 1.4, 2.5]\n```\n:::\n:::\n\n\n## `numpy.where`\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\nresult = np.where(cond, xarr, yarr)\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\narray([1.1, 2.2, 1.3, 1.4, 2.5])\n```\n:::\n:::\n\n\n:::\n\nCan also do this with scalars, or combine arrays and scalars:\n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\narr = rng.standard_normal((4,4))\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\narray([[-1.34360107, -0.08168759,  1.72473993,  2.61815943],\n       [ 0.77736134,  0.8286332 , -0.95898831, -1.20938829],\n       [-1.41229201,  0.54154683,  0.7519394 , -0.65876032],\n       [-1.22867499,  0.25755777,  0.31290292, -0.13081169]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\nnp.where(arr > 0, 2, -2)\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\narray([[-2, -2,  2,  2],\n       [ 2,  2, -2, -2],\n       [-2,  2,  2, -2],\n       [-2,  2,  2, -2]])\n```\n:::\n:::\n\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\n# set only positive to 2\nnp.where(arr > 0,2,arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\narray([[-1.34360107, -0.08168759,  2.        ,  2.        ],\n       [ 2.        ,  2.        , -0.95898831, -1.20938829],\n       [-1.41229201,  2.        ,  2.        , -0.65876032],\n       [-1.22867499,  2.        ,  2.        , -0.13081169]])\n```\n:::\n:::\n\n\n## Mathematical and Statistical Methods\n\nUse \"aggregations' like `sum`, `mean`, and `std`\n\n* If using NumPy, must pass the array you want to aggregate as the first argument\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\narr = rng.standard_normal((5, 4))\n\narr.mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=71}\n```\n0.06622379901441691\n```\n:::\n:::\n\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\nnp.mean(arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=72}\n```\n0.06622379901441691\n```\n:::\n:::\n\n\nCan use `axis` to specify which axis to computer the statistic\n\n:::{.panel-tabset}\n\n## \"compute across the columns\"\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\narr.mean(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\narray([ 0.00066383,  0.40377331,  0.44452789, -0.36983452, -0.14801151])\n```\n:::\n:::\n\n\n## \"compute across the rows\"\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\narr.mean(axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\narray([ 0.54494867, -0.10500845,  0.15080113, -0.32584615])\n```\n:::\n:::\n\n\n:::\n\nOther methods like cumsum and cumprod do not aggregate, instead producing an array of the intermediate results:\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\narr.cumsum()\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\narray([1.26998312e+00, 1.17702066e+00, 1.11086977e+00, 2.65530664e-03,\n       1.38612157e-01, 1.48568992e+00, 1.54683394e+00, 1.61774854e+00,\n       2.05140308e+00, 2.32888674e+00, 2.85913913e+00, 3.39586010e+00,\n       4.01421011e+00, 3.21919265e+00, 3.51922360e+00, 1.91652201e+00,\n       2.18332084e+00, 9.21697056e-01, 8.50426250e-01, 1.32447598e+00])\n```\n:::\n:::\n\n\nIn multidimensional arrays, accumulation functions like cumsum compute along the indicated axis:\n\n:::{.panel-tabset}\n\n## \"compute across the columns\"\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\narr.cumsum(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\narray([[ 1.26998312,  1.17702066,  1.11086977,  0.00265531],\n       [ 0.13595685,  1.48303461,  1.54417864,  1.61509324],\n       [ 0.43365454,  0.7111382 ,  1.24139058,  1.77811155],\n       [ 0.61835001, -0.17666744,  0.1233635 , -1.47933809],\n       [ 0.26679883, -0.99482495, -1.06609576, -0.59204603]])\n```\n:::\n:::\n\n\n## \"compute across the rows\"\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\narr.cumsum(axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=77}\n```\narray([[ 1.26998312, -0.09296246, -0.06615089, -1.10821447],\n       [ 1.40593997,  1.25411531, -0.00500687, -1.03729987],\n       [ 1.83959451,  1.53159897,  0.52524552, -0.5005789 ],\n       [ 2.45794452,  0.73658151,  0.82527646, -2.10328049],\n       [ 2.72474335, -0.52504227,  0.75400566, -1.62923076]])\n```\n:::\n:::\n\n\n:::\n\n## Methods for Boolean Arrays\n\nBoolean values are coerced to 1 (`True`) and 0 (`False`) in the preceding methods. Thus, sum is often used as a means of counting True values in a boolean array:\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\n(arr > 0).sum() # Number of positive values\n```\n\n::: {.cell-output .cell-output-display execution_count=78}\n```\n13\n```\n:::\n:::\n\n\n`any` tests whether one or more values in an array is True, while `all` checks if every value is True:\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\nbools = np.array([False, False, True, False])\nbools.any()\n```\n\n::: {.cell-output .cell-output-display execution_count=79}\n```\nTrue\n```\n:::\n:::\n\n\n## Sorting\n\nNumPy arrays can be sorted in place with the `sort` method:\n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\narr = rng.standard_normal(6)\narr.sort()\narr\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\narray([-1.64041784, -1.15452958, -0.85725882, -0.41485376,  0.0977165 ,\n        0.68828179])\n```\n:::\n:::\n\n\nCan sort multidimensional section by providing an axis:\n\n::: {.cell execution_count=81}\n``` {.python .cell-code}\narr = rng.standard_normal((5, 3))\n```\n:::\n\n\n:::{.panel-tabset}\n## \"compute across the columns\"\n\n::: {.cell execution_count=82}\n``` {.python .cell-code}\narr.cumsum(axis=1)\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\narray([[ 0.65045239, -0.73790756, -1.64529002],\n       [-1.09542531, -1.08827961, -0.55391971],\n       [-1.06580785, -1.24728059,  0.37467121],\n       [-0.31739195, -1.13320691, -0.7466279 ],\n       [-0.22363893, -0.92532973, -2.72104291]])\n```\n:::\n:::\n\n\n## \"compute across the rows\"\n\n::: {.cell execution_count=83}\n``` {.python .cell-code}\narr.cumsum(axis=0)\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\narray([[ 0.65045239, -1.38835995, -0.90738246],\n       [-0.44497292, -1.38121426, -0.37302255],\n       [-1.51078076, -1.562687  ,  1.24892924],\n       [-1.82817271, -2.37850196,  1.63550826],\n       [-2.05181164, -3.08019277, -0.16020491]])\n```\n:::\n:::\n\n\n:::\n\nThe top-level method `numpy.sort` returns a sorted copy of an array (like the Python built-in function `sorted`) instead of modifying the array in place:\n\n::: {.cell execution_count=84}\n``` {.python .cell-code}\narr2 = np.array([5, -10, 7, 1, 0, -3])\nsorted_arr2 = np.sort(arr2)\nsorted_arr2\n```\n\n::: {.cell-output .cell-output-display execution_count=84}\n```\narray([-10,  -3,   0,   1,   5,   7])\n```\n:::\n:::\n\n\n## Unique and Other Set Logic\n\n`numpy.unique` returns the sorted unique values in an array:\n\n::: {.cell execution_count=85}\n``` {.python .cell-code}\nnp.unique(names)\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\narray(['Bob', 'Joe', 'Will'], dtype='<U4')\n```\n:::\n:::\n\n\n`numpy.in1d` tests membership of the values in one array in another, returning a boolean array:\n\n::: {.cell execution_count=86}\n``` {.python .cell-code}\nnp.in1d(arr1, arr2)\n```\n\n::: {.cell-output .cell-output-display execution_count=86}\n```\narray([False, False, False, False, False, False, False, False, False,\n       False])\n```\n:::\n:::\n\n\n## File Input and Output with Arrays\n\nNumPy is able to save `np.save` and load `np.load` data to and from disk in some text or binary formats.\n\nArrays are saved by default in an uncompressed raw binary format with file extension .npy:\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\narr = np.arange(10)\nnp.save(\"some_array\", arr)\n```\n:::\n\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\nnp.load(\"some_array.npy\")\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n* Save multiple arrays in an uncompressed archive using `numpy.savez`\n* If your data compresses well, use `numpy.savez_compressed` instead\n\n## 4.6 Linear Algebra\n\nLinear algebra operations, like matrix multiplication, decompositions, determinants, and other square matrix math, can be done with Numpy (`np.dot(y)` vs `x.dot(y)`):\n\n::: {.cell execution_count=89}\n``` {.python .cell-code}\nnp.dot(arr1, arr)\n```\n\n::: {.cell-output .cell-output-display execution_count=89}\n```\n7.221776767282354\n```\n:::\n:::\n\n\n## Example: Random Walks\n\n::: {.cell execution_count=90}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n#! blockstart\nimport random\nposition = 0\nwalk = [position]\nnsteps = 1000\nfor _ in range(nsteps):\n    step = 1 if random.randint(0, 1) else -1\n    position += step\n    walk.append(position)\n#! blockend\n\nplt.plot(walk[:100])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](04_main_files\\figure-html/cell-91-output-1.png){width=569 height=404}\n:::\n:::\n\n\n",
    "supporting": [
      "04_main_files"
    ],
    "filters": [],
    "includes": {}
  }
}