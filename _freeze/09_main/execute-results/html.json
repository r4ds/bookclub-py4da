{
  "hash": "2482f791162596fbca1dc3a17a0056e0",
  "result": {
    "markdown": "# 9. Plotting and Visualization\n\n## Learning Objectives\n\n::: incremental\n-   We are going to learn the basic data visualization technique using matplotlib, pandas and seaborn.\n:::\n\n# Introduction\n\nMaking informative visualizations is one of the most important tasks in every exploratory data analysis process and this can be done using **matplotlib.** It may be a part of the exploratory process for example, to help identify **outliers** or needed data transformations, or as a way of generating ideas for models. For others, building an interactive visualization for the web may be the end goal. Python has many add-on libraries for making static or dynamic visualizations, but I'll be mainly focused on **matplotlib** and libraries that build on top of it.\n\n## import the necessary library\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport seaborn as sns\n```\n:::\n\n\n::: panel-tabset\n## Demo_Dataset\n\n::: {.cell execution_count=2}\n```` { .cell-code}\n```{{python}}\n#| eval: false\ndata = np.arange(10)\n```\n\n````\n:::\n\n\n## Print\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n```\n:::\n:::\n\n\n:::\n\n::: panel-tabset\n## Code\n\n::: {.cell execution_count=4}\n```` { .cell-code}\n```{{python}}\n#| eval: false\nplt.plot(data)\n```\n\n````\n:::\n\n\n## Output\n\n::: {.cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-6-output-1.png){width=558 height=404}\n:::\n:::\n\n\n:::\n\n## We can use plt.show() function to display the plot in quarto\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nplt.show()\n```\n:::\n\n\nWhen we are in jupyter notebook we can use **%matplotlib notebook** so that we can display the plot, but when we are in Ipython we can use **%matplotlib** to display the plot.\n\n## Customization of the visualization\n\nWhile libraries like seaborn and pandas's built-in plotting functions will deal with many of the mundane details of making plots, should you wish to customize them beyond the function options provided, you will need to learn a bit about the matplotlib API.\n\n## Figures and Subplots\n\nPlots in **matplotlib** reside within a **Figure** object. You can create a new figure with **plt.figure ()**\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfig = plt.figure()\n```\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 672x480 with 0 Axes>\n```\n:::\n:::\n\n\n**plt.figure** has a number of options; notably, **figsize** will guarantee the figure has a certain size and aspect ratio if saved to disk.\n\nYou can't make a plot with a blank figure. You have to create one or more subplots using add_subplot\n\n## Add Subplot\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nax1 = fig.add_subplot(2,2, 1)\n\nax1\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<AxesSubplot:>\n```\n:::\n:::\n\n\nThis means that the figure should be 2 Ã— 2, and we're selecting the first of four subplots (numbered from 1). We can add more subplot\n\n## We can add more subplot\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nax2 = fig.add_subplot(2, 2, 2)\n\nax3 = fig.add_subplot(2, 2, 3)\n\nax2\n\nax3\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n<AxesSubplot:>\n```\n:::\n:::\n\n\n## Adding axis methods to the plot\n\nThese plot axis objects have various methods that create different types of plots, and it is preferred to use the axis methods over the top-level plotting functions like **plt.show()**. For example, we could make a line plot with the plot method.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfig = plt.figure()\n\nax1 = fig.add_subplot(2, 2, 1)\n\nax2 = fig.add_subplot(2, 2, 2)\n\nax3 = fig.add_subplot(2, 2, 3)\n\nax3.plot(np.random.standard_normal(50).cumsum(), color=\"black\",\nlinestyle=\"dashed\")\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-11-output-1.png){width=581 height=409}\n:::\n:::\n\n\nWe may notice output like **matplotlib.lines.Line2D** at when we are creating our visualization. matplotlib returns objects that reference the plot subcomponent that was just added. A lot of the time you can safely ignore this output, or you can put a **semicolon** at the end of the line to suppress the output.\n\nThe additional options instruct matplotlib to plot a black dashed line. The objects returned by **fig.add_subplot** here are **AxesSubplot** objects, on which you can directly plot on the other empty subplots by calling each one's instance method.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nax1.hist(np.random.standard_normal(100),bins=20,color=\"black\", alpha=0.3);\n\nax2.scatter(np.arange(30), np.arange(30) + 3*np.random.standard_normal(30));\n```\n:::\n\n\nTo make creating a grid of subplots more convenient, matplotlib includes a **plt.subplots** method that creates a new figure and returns a NumPy array containing the created subplot objects:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\naxes = plt.subplots(2, 3)\n\naxes\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n(<Figure size 672x480 with 6 Axes>,\n array([[<AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>],\n        [<AxesSubplot:>, <AxesSubplot:>, <AxesSubplot:>]], dtype=object))\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-13-output-2.png){width=581 height=409}\n:::\n:::\n\n\nThe axes array can then be indexed like a two-dimensional array; for example, **axes\\[0, 1\\]** refers to the subplot in the top row at the center\n\n## Scatter Plot\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nplt.style.use('_mpl-gallery')\n\n# make the data\nnp.random.seed(3)\nx = 4 + np.random.normal(0, 2, 24)\ny = 4 + np.random.normal(0, 2, len(x))\n# size and color:\nsizes = np.random.uniform(15, 80, len(x))\ncolors = np.random.uniform(15, 80, len(x))\n\n# plot\nfig, ax = plt.subplots()\n\nax.scatter(x, y, s=sizes, c=colors, vmin=0, vmax=100)\n\nax.set(xlim=(0, 8), xticks=np.arange(1, 8),\n       ylim=(0, 8), yticks=np.arange(1, 8))\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-14-output-1.png){width=221 height=225}\n:::\n:::\n\n\n## Bar Plot\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nplt.style.use('_mpl-gallery')\n\n# make data:\nnp.random.seed(3)\nx = 0.5 + np.arange(8)\ny = np.random.uniform(2, 7, len(x))\n\n# plot\nfig, ax = plt.subplots()\n\nax.bar(x, y, width=1, edgecolor=\"white\", linewidth=0.7)\n\nax.set(xlim=(0, 8), xticks=np.arange(1, 8),\n       ylim=(0, 8), yticks=np.arange(1, 8))\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-15-output-1.png){width=221 height=225}\n:::\n:::\n\n\n## Box Plot\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nplt.style.use('_mpl-gallery')\n\n# make data:\nnp.random.seed(10)\nD = np.random.normal((3, 5, 4), (1.25, 1.00, 1.25), (100, 3))\n\n# plot\nfig, ax = plt.subplots()\nVP = ax.boxplot(D, positions=[2, 4, 6], widths=1.5, patch_artist=True,\n                showmeans=False, showfliers=False,\n                medianprops={\"color\": \"white\", \"linewidth\": 0.5},\n                boxprops={\"facecolor\": \"C0\", \"edgecolor\": \"white\",\n                          \"linewidth\": 0.5},\n                whiskerprops={\"color\": \"C0\", \"linewidth\": 1.5},\n                capprops={\"color\": \"C0\", \"linewidth\": 1.5})\n\nax.set(xlim=(0, 8), xticks=np.arange(1, 8),\n       ylim=(0, 8), yticks=np.arange(1, 8))\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-16-output-1.png){width=221 height=225}\n:::\n:::\n\n\n[**We can learn more with the matplotlib documentation**](https://matplotlib.org)\n\n| Argument   | Description                                                                                                  |\n|--------------------|--------------------------------------------------------|\n| nrows      | Number of rows of subplots                                                                                   |\n| ncols      | Number of columns of subplots                                                                                |\n| sharex     | All subplots should use the same x-axis ticks (adjusting the xlim will affect all subplots)                  |\n| sharey     | All subplots should use the same y-axis ticks (adjusting the ylim will affect all subplots)                  |\n| subplot_kw | Dictionary of keywords passed to add_subplot call used to create each subplot                                |\n| **fig_kw** | Additional keywords to subplots are used when creating the figure, such as plt.subplots (2,2, figsize=(8,6)) |\n\n: Table.1: Matplotlib.pyplot.subplots options\n\n## Adjusting the spacing around subplots\n\nBy default, matplotlib leaves a certain amount of padding around the outside of the subplots and in spacing between subplots. This spacing is all specified relative to the height and width of the plot, so that if you resize the plot either programmatically or manually using the GUI window, the plot will dynamically adjust itself. You can change the spacing using the subplots_adjust method on Figure objects:\n\nsubplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None)\n\n**wspace** and **hspace** control the percent of the figure width and figure height, respectively, to use as spacing between subplots.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 2, sharex=True, sharey=True)\nfor i in range(2):\n    for j in range(2):\n        axes[i, j].hist(np.random.standard_normal(500), bins=50,\n                        color=\"black\", alpha=0.5)\nfig.subplots_adjust(wspace=0, hspace=0)\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-17-output-1.png){width=229 height=225}\n:::\n:::\n\n\n## **Colors, Markers, and Line Styles**\n\nmatplotlib's line `plot` function accepts arrays of x and y coordinates and optional color styling options. For example, to plot `x` versus `y` with green dashes, you would execute:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nax.plot(x, y, linestyle=\"--\", color=\"green\")\n```\n:::\n\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nax = fig.add_subplot()\n\nax.plot(np.random.standard_normal(30).cumsum(), color=\"black\",\nlinestyle=\"dashed\", marker=\"o\")\n\nplt.show()\n```\n:::\n\n\nline plots, you will notice that subsequent points are **linearly interpolated** by default. This can be altered with the **drawstyle** option.\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfig = plt.figure()\n\nax = fig.add_subplot()\n\ndata = np.random.standard_normal(30).cumsum()\n\nax.plot(data, color=\"black\", linestyle=\"dashed\", label=\"Default\");\nax.plot(data, color=\"black\", linestyle=\"dashed\",\ndrawstyle=\"steps-post\", label=\"steps-post\");\nax.legend()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n<matplotlib.legend.Legend at 0x2c090478040>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-20-output-2.png){width=237 height=227}\n:::\n:::\n\n\n## Ticks, Labels, and Legends\n\nMost kinds of plot decorations can be accessed through methods on matplotlib axes objects. This includes methods like **xlim**, **xticks**, and **xticklabels**. These control the **plot range**, **tick locations**, and **tick labels**, respectively. They can be used in two ways:\n\n-   Called with no arguments returns the current parameter value (e.g., **ax.xlim()** returns the current **x-axis** plotting range)\n\n-   Called with parameters sets the parameter value (e.g., **ax.xlim**(\\[0, 10\\]) sets the x-axis range to 0 to 10)\n\n## Setting the title, axis labels, ticks, and tick labels\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\n\nax.plot(np.random.standard_normal(1000).cumsum());\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-21-output-1.png){width=249 height=225}\n:::\n:::\n\n\nTo change the **x-axis ticks**, it's easiest to use **set_xticks** and **set_xticklabels**. The former instructs matplotlib where to place the ticks along the data range; by default these locations will also be the labels. But we can set any other values as the labels using **set_xticklabels:**\n\nThe rotation option sets the x tick labels at a 30-degree rotation. Lastly, **set_xlabel** gives a name to the x-axis, and set_title is the subplot title.\n\n## Adding legends\n\nLegends are another critical element for identifying plot elements. There are a couple of ways to add one. The easiest is to pass the label argument when adding each piece of the plot:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\n\nax.plot(np.random.randn(1000).cumsum(), color=\"black\", label=\"one\");\nax.plot(np.random.randn(1000).cumsum(), color=\"black\", linestyle=\"dashed\",\nlabel=\"two\");\nax.plot(np.random.randn(1000).cumsum(), color=\"black\", linestyle=\"dotted\",\nlabel=\"three\");\n\n\nax.legend()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n<matplotlib.legend.Legend at 0x2c0904e2b90>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-22-output-2.png){width=249 height=225}\n:::\n:::\n\n\nThe legend method has several other choices for the location **loc argument**. See the docstring (with **ax.legend?**) for more information. The **loc legend** option tells matplotlib where to place the plot. The default is **\"best\"**, which tries to choose a location that is most out of the way. To exclude one or more elements from the legend, pass **no label** or **label=\"*nolegend*\"**.\n\n## Saving Plots to File\n\nYou can save the active figure to file using the figure object's savefig instance method. For example, to save an SVG version of a figure, you need only type:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nfig.savefig(\"figpath.png\", dpi=400)\n```\n:::\n\n\n| Argument             | Description                                                                                                                                                |\n|-----------------|-------------------------------------------------------|\n| fname                | String containing a filepath or a Python file-like object. The figure format is inferred from the file extension (e.g., `.pdf` for PDF or `.png` for PNG). |\n| dpi                  | The figure resolution in dots per inch; defaults to 100 in IPython or 72 in Jupyter out of the box but can be configured.                                  |\n| facecolor, edgecolor | The color of the figure background outside of the subplots; `\"w\"` (white), by default.                                                                     |\n| format               | The explicit file format to use (`\"png\"`, `\"pdf\"`, `\"svg\"`, `\"ps\"`, `\"eps\"`, \\...).                                                                        |\n\n: Table 9.2: Some fig.savefig options\n\n### **matplotlib Configuration**\n\nmatplotlib comes configured with color schemes and defaults that are geared primarily toward preparing figures for publication. Fortunately, nearly all of the default behavior can be customized via global parameters governing figure size, subplot spacing, colors, font sizes, grid styles, and so on. One way to modify the configuration programmatically from Python is to use the **`rc`** method; for example, to set the global default figure size to be 10 Ã— 10, you could enter:\n\nThe first argument to `rc` is the component you wish to customize, such as **`\"figure\"`**, **`\"axes\"`**, **`\"xtick\"`**, **`\"ytick\"`**, **`\"grid\"`**, **`\"legend\"`**, or many others. After that can follow a sequence of keyword arguments indicating the new parameters. A convenient way to write down the options in your program is as a dictionary:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nplt.rc(\"font\", family=\"monospace\", weight=\"bold\", size=8)\n```\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nplt.rc(\"figure\", figsize=(10, 10))\n```\n:::\n\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nplt.rc(\"font\", family=\"monospace\", weight=\"bold\", size=8)\n```\n:::\n\n\nFor more extensive customization and to see a list of all the options, matplotlib comes with a configuration file ***matplotlibrc*** in the ***matplotlib/mpl-data*** **directory**. If you customize this file and place it in your home directory **titled *.matplotlibrc***, it will be loaded each time you use **matplotlib**.\n\nAll of the current configuration settings are found in the **plt.rcParams dictionary**, and they can be restored to their default values by calling the **plt.rcdefaults()** function.\n\nThe first argument to **rc** is the component you wish to customize, such as **\"figure\"**, **\"axes\"**, **\"xtick\"**, **\"ytick\"**, **\"grid\"**, **\"legend\"**, or many others. After that can follow a sequence of keyword arguments indicating the new parameters. A convenient way to write down the options in your program is as a dictionary:\n\n## Plotting with pandas and seaborn\n\n**matplotlib** can be a fairly low-level tool. You assemble a plot from its base components: the data display (i.e., the type of plot: line, bar, box, scatter, contour, etc.), legend, title, tick labels, and other annotations. In **pandas**, we may have multiple columns of data, along with row and column labels. pandas itself has built-in methods that simplify creating visualizations from DataFrame and Series objects. Another library is **seaborn**, a high-level statistical graphics library built on matplotlib. seaborn simplifies creating many common visualization types.\n\n## Plotting with Pandas\n\n## Line Plots\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ns = pd.Series(np.random.standard_normal(10).cumsum(), index=np.arange(0,\n 100, 10))\n\ns.plot()\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-27-output-2.png){width=990 height=975}\n:::\n:::\n\n\nThe Series object's index is passed to **matplotlib** for plotting on the x-axis, though you can disable this by passing **use_index=False**. The x-axis ticks and limits can be adjusted with the **xticks** and **xlim** options, and the **y-axis** respectively with **yticks** and **ylim**.\n\n| Argument  | Description                                                                                                          |\n|----------------|--------------------------------------------------------|\n| label     | Label for plot legend                                                                                                |\n| ax        | matplotlib subplot object to plot on; if nothing passed, uses active matplotlib subplot                              |\n| style     | Style string, like `\"ko--\"`, to be passed to matplotlib                                                              |\n| alpha     | The plot fill opacity (from 0 to 1)                                                                                  |\n| kind      | Can be `\"area\"`, `\"bar\"`, `\"barh\"`, `\"density\"`, `\"hist\"`, `\"kde\"`, `\"line\"`, or `\"pie\"`; defaults to `\"line\"`       |\n| figsize   | Size of the figure object to create                                                                                  |\n| logx      | Pass `True` for logarithmic scaling on the x axis; pass `\"sym\"` for symmetric logarithm that permits negative values |\n| logy      | Pass `True` for logarithmic scaling on the y axis; pass `\"sym\"` for symmetric logarithm that permits negative values |\n| title     | Title to use for the plot                                                                                            |\n| use_index | Use the object index for tick labels                                                                                 |\n| rot       | Rotation of tick labels (0 through 360)                                                                              |\n| xticks    | Values to use for x-axis ticks                                                                                       |\n| yticks    | Values to use for y-axis ticks                                                                                       |\n| xlim      | x-axis limits (e.g., `[0, 10]`)                                                                                      |\n| ylim      | y-axis limits                                                                                                        |\n| grid      | Display axis grid (off by default)                                                                                   |\n\n: Table 9.3: Series.plot method arguments\n\n## Line Graph\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndf = pd.DataFrame(np.random.standard_normal((10, 4)).cumsum(0),\ncolumns=[\"A\", \"B\", \"C\", \"D\"],\nindex=np.arange(0, 100, 10))\n\nplt.style.use('grayscale')\n\ndf.plot()\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-28-output-2.png){width=978 height=975}\n:::\n:::\n\n\nHere I used `plt.style.use('grayscale')` to switch to a color scheme more suitable for black and white publication, since some readers will not be able to see the full color plots. The `plot` attribute contains a \"family\" of methods for different plot types. For example, `df.plot()` is equivalent to `df.plot.line()`\n\n## Bar Plots\n\nThe **plot.bar()** and **plot.barh()** make vertical and horizontal bar plots, respectively. In this case, the Series or DataFrame index will be used as the x **(bar)** or y **(barh)** ticks\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nfig, axes = plt.subplots(2, 1)\n\ndata = pd.Series(np.random.uniform(size=16), index=list(\"abcdefghijklmnop\"))\n\ndata.plot.bar(ax=axes[0], color=\"black\", alpha=0.7)\n\ndata.plot.barh(ax=axes[1], color=\"black\", alpha=0.7)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-29-output-2.png){width=984 height=975}\n:::\n:::\n\n\n## With a DataFrame, bar plots group the values in each row in bars, side by side, for each value.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\ndf = pd.DataFrame(np.random.uniform(size=(6, 4)),\nindex=[\"one\", \"two\", \"three\", \"four\", \"five\", \"six\"],\ncolumns=pd.Index([\"A\", \"B\", \"C\", \"D\"], name=\"Genus\"))\n\ndf\n \n\ndf.plot.bar()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-30-output-2.png){width=984 height=997}\n:::\n:::\n\n\n## We create stacked bar plots from a DataFrame by passing **stacked=True**, resulting in the value in each row being stacked together horizontally\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\ndf.plot.barh(stacked=True, alpha=0.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-31-output-2.png){width=997 height=975}\n:::\n:::\n\n\n## Visualizing categorical data with Seaborn\n\nPlotting functions in seaborn take a `data` argument, which can be a pandas DataFrame. The other arguments refer to column names.\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nimport seaborn as sns\ntips = sns.load_dataset(\"tips\")\nsns.catplot(data=tips, x=\"day\", y=\"total_bill\")\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c08fd8c2b0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-32-output-2.png){width=476 height=476}\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nsns.catplot(data=tips, x=\"day\", y=\"total_bill\", hue=\"sex\", kind=\"swarm\")\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c092177ac0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-33-output-2.png){width=551 height=476}\n:::\n:::\n\n\n## Boxplot\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nsns.catplot(data=tips, x=\"day\", y=\"total_bill\", kind=\"box\")\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c0906cbfd0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-34-output-2.png){width=476 height=476}\n:::\n:::\n\n\n## Barplot\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\ntitanic = sns.load_dataset(\"titanic\")\nsns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"bar\")\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c0904e2bf0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-35-output-2.png){width=551 height=476}\n:::\n:::\n\n\n## Scatter Plot\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nimport pandas as pd\nimport seaborn as sns\npenguin=pd.read_excel('data/penguins.xlsx')\n\nax = sns.regplot(x=\"bill_length_mm\", y=\"flipper_length_mm\", data=penguin)\n\nax\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\n<AxesSubplot:xlabel='bill_length_mm', ylabel='flipper_length_mm'>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-36-output-2.png){width=1000 height=990}\n:::\n:::\n\n\nIn exploratory data analysis, it's helpful to be able to look at all the scatter plots among a group of variables; this is known as a *pairs* plot or *scatter plot matrix.*\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\n sns.pairplot(penguin, diag_kind=\"kde\", plot_kws={\"alpha\": 0.2})\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\n<seaborn.axisgrid.PairGrid at 0x2c0902b90c0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-37-output-2.png){width=1655 height=1654}\n:::\n:::\n\n\nThis **plot_kws** enables us to pass down configuration options to the individual plotting calls on the off-diagonal elements.\n\n**Point Plot**\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\nsns.catplot(data=titanic, x=\"sex\", y=\"survived\", hue=\"class\", kind=\"point\")\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c08fdda5c0>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-38-output-2.png){width=551 height=476}\n:::\n:::\n\n\n## Line Plot\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nsns.set_theme(style=\"whitegrid\")\n\nrs = np.random.RandomState(365)\nvalues = rs.randn(365, 4).cumsum(axis=0)\ndates = pd.date_range(\"1 1 2016\", periods=365, freq=\"D\")\ndata = pd.DataFrame(values, dates, columns=[\"A\", \"B\", \"C\", \"D\"])\ndata = data.rolling(7).mean()\n\nsns.lineplot(data=data, palette=\"tab10\", linewidth=2.5)\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n<AxesSubplot:>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-39-output-2.png){width=998 height=987}\n:::\n:::\n\n\n## **Facet Grids and Categorical Data**\n\nOne way to visualize data with many categorical variables is to use a ***facet grid***, which is a **two-dimensional layout** of plots where the data is split across the plots on each axis based on the distinct values of a certain variable. **seaborn** has a useful built-in function **`catplot`** that simplifies making many kinds of faceted plots split by **categorical variables**\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nsns.catplot(x=\"species\", y=\"bill_length_mm\", hue=\"sex\", col=\"island\",\nkind=\"bar\", data=penguin)\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c09fc18280>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-40-output-2.png){width=1529 height=464}\n:::\n:::\n\n\n**`catplot`** supports other plot types that may be useful depending on what you are trying to display. For example, *box plots* (which show the median, quartiles, and outliers) can be an effective visualization type.\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nsns.catplot(x=\"bill_length_mm\", y=\"island\", kind=\"box\",\ndata=penguin)\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n<seaborn.axisgrid.FacetGrid at 0x2c0984ba440>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](09_main_files\\figure-html/cell-41-output-2.png){width=464 height=464}\n:::\n:::\n\n\n## **Other Python Visualization Tools**\n\n-   There are many other tools for data visualization in python such as \\[[Altair](https://altair-viz.github.io/)\\](https://altair-viz.github.io/); \\[[Bokeh](http://bokeh.pydata.org/)\\](http://bokeh.pydata.org/) and \\[[Plotly](https://plotly.com/python)\\](https://plotly.com/python)\n\n-   For creating static graphics for print or web, I recommend using matplotlib and libraries that build on matplotlib, like pandas and seaborn, for your needs.\n\n",
    "supporting": [
      "09_main_files"
    ],
    "filters": [],
    "includes": {}
  }
}