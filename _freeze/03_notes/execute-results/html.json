{
  "hash": "a86f5473b36b2a2ee435de96ebd98d3d",
  "result": {
    "markdown": "# Data Structures and Sequences\n\n## Tuples\n\n![](https://pynative.com/wp-content/uploads/2021/02/python-tuple.jpg)\n\nA tuple is a fixed-length, immutable sequence of Python objects which, once assigned, cannot be changed. The easiest way to create one is with a comma-separated sequence of values wrapped in parentheses:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ntup = (4, 5, 6)\ntup\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(4, 5, 6)\n```\n:::\n:::\n\n\nIn many contexts, the parentheses can be omitted\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntup = 4, 5, 6\ntup\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n(4, 5, 6)\n```\n:::\n:::\n\n\nYou can convert any sequence or iterator to a tuple by invoking\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ntuple([4,0,2])\n\ntup = tuple('string')\n\ntup\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n('s', 't', 'r', 'i', 'n', 'g')\n```\n:::\n:::\n\n\nElements can be accessed with square brackets [] \n\nNote the zero indexing\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ntup[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n's'\n```\n:::\n:::\n\n\nTuples of tuples\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nnested_tup = (4,5,6),(7,8)\n\nnested_tup\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n((4, 5, 6), (7, 8))\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnested_tup[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n(4, 5, 6)\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnested_tup[1]\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(7, 8)\n```\n:::\n:::\n\n\nWhile the objects stored in a tuple may be mutable themselves, once the tuple is created it’s not possible to modify which object is stored in each slot:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ntup = tuple(['foo', [1, 2], True])\n\ntup[2]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nTrue\n```\n:::\n:::\n\n\n```{{python}}\n\ntup[2] = False\n\n```\n\n````\nTypeError                                 Traceback (most recent call last)\nInput In [9], in <cell line: 1>()\n----> 1 tup[2] = False\n\nTypeError: 'tuple' object does not support item assignment\nTypeError: 'tuple' object does not support item assignment\n````\n\nIf an object inside a tuple is mutable, such as a list, you can modify it in place\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ntup[1].append(3)\n\ntup\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n('foo', [1, 2, 3], True)\n```\n:::\n:::\n\n\nYou can concatenate tuples using the + operator to produce longer tuples:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n(4, None, 'foo') + (6, 0) + ('bar',)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n(4, None, 'foo', 6, 0, 'bar')\n```\n:::\n:::\n\n\n### Unpacking tuples\n\nIf you try to assign to a tuple-like expression of variables, Python will attempt to unpack the value on the righthand side of the equals sign:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ntup = (4, 5, 6)\ntup\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n(4, 5, 6)\n```\n:::\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\na, b, c = tup\n\nc\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n6\n```\n:::\n:::\n\n\nEven sequences with nested tuples can be unpacked:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ntup = 4, 5, (6,7)\n\na, b, (c, d) = tup\n\nd\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n7\n```\n:::\n:::\n\n\nTo easily swap variable names\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\na, b = 1, 4\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n1\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n4\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nb, a = a, b\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n4\n```\n:::\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n1\n```\n:::\n:::\n\n\nA common use of variable unpacking is iterating over sequences of tuples or lists\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\nseq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n\nseq\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n[(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nfor a, b, c in seq:\n     print(f'a={a}, b={b}, c={c}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na=1, b=2, c=3\na=4, b=5, c=6\na=7, b=8, c=9\n```\n:::\n:::\n\n\n`*rest` syntax for plucking elements\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nvalues = 1,2,3,4,5\n\na, b, *rest = values\n\nrest\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n[3, 4, 5]\n```\n:::\n:::\n\n\n As a matter of convention, many Python programmers will use the underscore (_) for unwanted variables:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\na, b, *_ = values\n```\n:::\n\n\n### Tuple methods\n\nSince the size and contents of a tuple cannot be modified, it is very light on instance methods. A particularly useful one (also available on lists) is `count`\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\na = (1,2,2,2,2,3,4,5,7,8,9)\n\na.count(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n4\n```\n:::\n:::\n\n\n## List\n\n![](https://pynative.com/wp-content/uploads/2021/03/python-list.jpg)\n\nIn contrast with tuples, lists are variable length and their contents can be modified in place.\n\nLists are mutable. \n\nLists use `[]` square brackts or the `list` function\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\na_list = [2, 3, 7, None]\n\ntup = (\"foo\", \"bar\", \"baz\")\n\nb_list = list(tup)\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\n['foo', 'bar', 'baz']\n```\n:::\n:::\n\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nb_list[1] = \"peekaboo\"\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n['foo', 'peekaboo', 'baz']\n```\n:::\n:::\n\n\nLists and tuples are semantically similar (though tuples cannot be modified) and can be used interchangeably in many functions.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\ngen = range(10)\n\ngen\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nrange(0, 10)\n```\n:::\n:::\n\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nlist(gen)\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n### Adding and removing list elements\n\nthe `append` method\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nb_list.append(\"dwarf\")\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n['foo', 'peekaboo', 'baz', 'dwarf']\n```\n:::\n:::\n\n\nthe `insert` method\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nb_list.insert(1, \"red\")\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n['foo', 'red', 'peekaboo', 'baz', 'dwarf']\n```\n:::\n:::\n\n\n`insert` is computationally more expensive than `append`\n\nthe `pop` method, the inverse of `insert`\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nb_list.pop(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n'peekaboo'\n```\n:::\n:::\n\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\n['foo', 'red', 'baz', 'dwarf']\n```\n:::\n:::\n\n\nthe `remove` method\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\nb_list.append(\"foo\")\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\n['foo', 'red', 'baz', 'dwarf', 'foo']\n```\n:::\n:::\n\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nb_list.remove(\"foo\")\n\nb_list\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\n['red', 'baz', 'dwarf', 'foo']\n```\n:::\n:::\n\n\nCheck if a list contains a value using the `in` keyword:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\n\"dwarf\" in b_list\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\nTrue\n```\n:::\n:::\n\n\nThe keyword `not` can be used to negate an `in`\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n\"dwarf\" not in b_list\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\nFalse\n```\n:::\n:::\n\n\n### Concatenating and combining lists\n\nsimilar with tuples, use `+` to concatenate\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n[4, None, \"foo\"] + [7, 8, (2, 3)]\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n[4, None, 'foo', 7, 8, (2, 3)]\n```\n:::\n:::\n\n\nthe `extend` method\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nx = [4, None, \"foo\"]\n\nx.extend([7,8,(2,3)])\n\nx\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n[4, None, 'foo', 7, 8, (2, 3)]\n```\n:::\n:::\n\n\nlist concatenation by addition is an expensive operation\n\nusing `extend` is preferable\n\n```{{python}}\neverything = []\nfor chunk in list_of_lists:\n    everything.extend(chunk)\n\n```\n\nis generally faster than\n\n```{{python}}\n\neverything = []\nfor chunk in list_of_lists:\n    everything = everything + chunk\n\n```\n\n### Sorting\n\nthe `sort` method\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\na = [7, 2, 5, 1, 3]\n\na.sort()\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\n[1, 2, 3, 5, 7]\n```\n:::\n:::\n\n\n`sort` options\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\nb = [\"saw\", \"small\", \"He\", \"foxes\", \"six\"]\n\nb.sort(key = len)\n\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\n['He', 'saw', 'six', 'small', 'foxes']\n```\n:::\n:::\n\n\n### Slicing\n\nSlicing semantics takes a bit of getting used to, especially if you’re coming from R or MATLAB.\n\nusing the indexing operator `[]`\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\nseq = [7, 2, 3, 7, 5, 6, 0, 1]\n\nseq[3:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\n[7, 5]\n```\n:::\n:::\n\n\nalso assigned with a sequence\n\n::: {.cell execution_count=40}\n``` {.python .cell-code}\nseq[3:5] = [6,3]\n\nseq\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\n[7, 2, 3, 6, 3, 6, 0, 1]\n```\n:::\n:::\n\n\nEither the `start` or `stop` can be omitted\n\n::: {.cell execution_count=41}\n``` {.python .cell-code}\nseq[:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\n[7, 2, 3, 6, 3]\n```\n:::\n:::\n\n\n::: {.cell execution_count=42}\n``` {.python .cell-code}\nseq[3:]\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\n[6, 3, 6, 0, 1]\n```\n:::\n:::\n\n\nNegative indices slice the sequence relative to the end:\n\n::: {.cell execution_count=43}\n``` {.python .cell-code}\nseq[-4:]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\n[3, 6, 0, 1]\n```\n:::\n:::\n\n\nA step can also be used after a second colon to, say, take every other element:\n\n::: {.cell execution_count=44}\n``` {.python .cell-code}\nseq[::2]\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\n[7, 3, 3, 0]\n```\n:::\n:::\n\n\nA clever use of this is to pass -1, which has the useful effect of reversing a list or tuple:\n\n::: {.cell execution_count=45}\n``` {.python .cell-code}\nseq[::-1]\n```\n\n::: {.cell-output .cell-output-display execution_count=45}\n```\n[1, 0, 6, 3, 6, 3, 2, 7]\n```\n:::\n:::\n\n\n## Dictionary\n\n![](https://pynative.com/wp-content/uploads/2021/02/dictionaries-in-python.jpg)\n\nThe dictionary or dict may be the most important built-in Python data structure. \n\nOne approach for creating a dictionary is to use curly braces {} and colons to separate keys and values:\n\n::: {.cell execution_count=46}\n``` {.python .cell-code}\nempty_dict = {}\n\nd1 = {\"a\": \"some value\", \"b\": [1, 2, 3, 4]}\n\nd1\n```\n\n::: {.cell-output .cell-output-display execution_count=46}\n```\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n```\n:::\n:::\n\n\naccess, insert, or set elements \n\n::: {.cell execution_count=47}\n``` {.python .cell-code}\nd1[7] = \"an integer\"\n\nd1\n```\n\n::: {.cell-output .cell-output-display execution_count=47}\n```\n{'a': 'some value', 'b': [1, 2, 3, 4], 7: 'an integer'}\n```\n:::\n:::\n\n\nand as before\n\n::: {.cell execution_count=48}\n``` {.python .cell-code}\n\"b\" in d1\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\nTrue\n```\n:::\n:::\n\n\nthe `del` and `pop` methods\n\n::: {.cell execution_count=49}\n``` {.python .cell-code}\ndel d1[7]\n\nd1\n```\n\n::: {.cell-output .cell-output-display execution_count=49}\n```\n{'a': 'some value', 'b': [1, 2, 3, 4]}\n```\n:::\n:::\n\n\n::: {.cell execution_count=50}\n``` {.python .cell-code}\nret = d1.pop(\"a\")\n\nret\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```\n'some value'\n```\n:::\n:::\n\n\nThe `keys` and `values` methods\n\n::: {.cell execution_count=51}\n``` {.python .cell-code}\nlist(d1.keys())\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```\n['b']\n```\n:::\n:::\n\n\n::: {.cell execution_count=52}\n``` {.python .cell-code}\nlist(d1.values())\n```\n\n::: {.cell-output .cell-output-display execution_count=52}\n```\n[[1, 2, 3, 4]]\n```\n:::\n:::\n\n\nthe `items` method\n\n::: {.cell execution_count=53}\n``` {.python .cell-code}\nlist(d1.items())\n```\n\n::: {.cell-output .cell-output-display execution_count=53}\n```\n[('b', [1, 2, 3, 4])]\n```\n:::\n:::\n\n\n the update method to merge one dictionary into another\n\n::: {.cell execution_count=54}\n``` {.python .cell-code}\nd1.update({\"b\": \"foo\", \"c\": 12})\n\nd1\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n{'b': 'foo', 'c': 12}\n```\n:::\n:::\n\n\n ### Creating dictionaries from sequences\n\n::: {.cell execution_count=55}\n``` {.python .cell-code}\nlist(range(5))\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```\n[0, 1, 2, 3, 4]\n```\n:::\n:::\n\n\n::: {.cell execution_count=56}\n``` {.python .cell-code}\ntuples = zip(range(5), reversed(range(5)))\n\ntuples\n\nmapping = dict(tuples)\n\nmapping\n```\n\n::: {.cell-output .cell-output-display execution_count=56}\n```\n{0: 4, 1: 3, 2: 2, 3: 1, 4: 0}\n```\n:::\n:::\n\n\n### Default values\n\nimagine categorizing a list of words by their first letters as a dictionary of lists\n\n::: {.cell execution_count=57}\n``` {.python .cell-code}\nwords = [\"apple\", \"bat\", \"bar\", \"atom\", \"book\"]\n\nby_letter = {}\n\nfor word in words:\n        letter = word[0]\n        if letter not in by_letter:\n            by_letter[letter] = [word]\n        else:\n            by_letter[letter].append(word)\n\nby_letter\n```\n\n::: {.cell-output .cell-output-display execution_count=57}\n```\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n```\n:::\n:::\n\n\nThe `setdefault` dictionary method can be used to simplify this workflow. The preceding for loop can be rewritten as:\n\n::: {.cell execution_count=58}\n``` {.python .cell-code}\nby_letter = {}\n\nfor word in words:\n        letter = word[0]\n        by_letter.setdefault(letter, []).append(word)\n\nby_letter\n```\n\n::: {.cell-output .cell-output-display execution_count=58}\n```\n{'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']}\n```\n:::\n:::\n\n\nThe built-in `collections`module has a useful class, `defaultdict`, which makes this even easier.\n\n::: {.cell execution_count=59}\n``` {.python .cell-code}\nfrom collections import defaultdict\n\nby_letter = defaultdict(list)\n\nfor word in words:\n        by_letter[word[0]].append(word)\n\nby_letter\n```\n\n::: {.cell-output .cell-output-display execution_count=59}\n```\ndefaultdict(list, {'a': ['apple', 'atom'], 'b': ['bat', 'bar', 'book']})\n```\n:::\n:::\n\n\n### Valid dictionary key types\n\nkeys generally have to be immutable objects like scalars or tuples for *hashability*\n\nTo use a list as a key, one option is to convert it to a tuple, which can be hashed as long as its elements also can be:\n\n::: {.cell execution_count=60}\n``` {.python .cell-code}\nd = {}\n\nd[tuple([1,2,3])] = 5\n\nd\n```\n\n::: {.cell-output .cell-output-display execution_count=60}\n```\n{(1, 2, 3): 5}\n```\n:::\n:::\n\n\n## Set\n\n![](https://pynative.com/wp-content/uploads/2021/03/python-sets.jpg)\n\ncan be created in two ways: via the `set` function or via a `set literal` with curly braces:\n\n::: {.cell execution_count=61}\n``` {.python .cell-code}\nset([2, 2, 2, 1, 3, 3])\n\n{2,2,1,3,3}\n```\n\n::: {.cell-output .cell-output-display execution_count=61}\n```\n{1, 2, 3}\n```\n:::\n:::\n\n\nSets support mathematical set operations like union, intersection, difference, and symmetric difference.\n\nThe `union` of these two sets:\n\n::: {.cell execution_count=62}\n``` {.python .cell-code}\na = {1, 2, 3, 4, 5}\n\nb = {3, 4, 5, 6, 7, 8}\n\na.union(b)\n\na | b\n```\n\n::: {.cell-output .cell-output-display execution_count=62}\n```\n{1, 2, 3, 4, 5, 6, 7, 8}\n```\n:::\n:::\n\n\nThe `&`operator or the `intersection` method\n\n::: {.cell execution_count=63}\n``` {.python .cell-code}\na.intersection(b)\n\na & b\n```\n\n::: {.cell-output .cell-output-display execution_count=63}\n```\n{3, 4, 5}\n```\n:::\n:::\n\n\n[A table of commonly used `set` methods](https://wesmckinney.com/book/python-builtin.html#tbl-table_set_operations)\n\nAll of the logical set operations have in-place counterparts, which enable you to replace the contents of the set on the left side of the operation with the result. For very large sets, this may be more efficient\n\n::: {.cell execution_count=64}\n``` {.python .cell-code}\nc = a.copy()\n\nc |= b\n\nc\n```\n\n::: {.cell-output .cell-output-display execution_count=64}\n```\n{1, 2, 3, 4, 5, 6, 7, 8}\n```\n:::\n:::\n\n\n::: {.cell execution_count=65}\n``` {.python .cell-code}\nd = a.copy()\n\nd &= b\n\nd\n```\n\n::: {.cell-output .cell-output-display execution_count=65}\n```\n{3, 4, 5}\n```\n:::\n:::\n\n\nset elements generally must be immutable, and they must be hashable\n\nyou can convert them to tuples\n\nYou can also check if a set is a subset of (is contained in) or a superset of (contains all elements of) another set\n\n::: {.cell execution_count=66}\n``` {.python .cell-code}\na_set = {1, 2, 3, 4, 5}\n\n{1, 2, 3}.issubset(a_set)\n```\n\n::: {.cell-output .cell-output-display execution_count=66}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=67}\n``` {.python .cell-code}\na_set.issuperset({1, 2, 3})\n```\n\n::: {.cell-output .cell-output-display execution_count=67}\n```\nTrue\n```\n:::\n:::\n\n\n## Built-In Sequence Functions\n\n### enumerate\n\n`enumerate` returns a sequence of (i, value) tuples\n\n### sorted\n\n`sorted` returns a new sorted list \n\n::: {.cell execution_count=68}\n``` {.python .cell-code}\nsorted([7,1,2,9,3,6,5,0,22])\n```\n\n::: {.cell-output .cell-output-display execution_count=68}\n```\n[0, 1, 2, 3, 5, 6, 7, 9, 22]\n```\n:::\n:::\n\n\n### zip\n\n`zip` “pairs” up the elements of a number of lists, tuples, or other sequences to create a list of tuples\n\n::: {.cell execution_count=69}\n``` {.python .cell-code}\nseq1 = [\"foo\", \"bar\", \"baz\"]\n\nseq2 = [\"one\", \"two\", \"three\"]\n\nzipped = zip(seq1, seq2)\n\nlist(zipped)\n```\n\n::: {.cell-output .cell-output-display execution_count=69}\n```\n[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]\n```\n:::\n:::\n\n\n`zip` can take an arbitrary number of sequences, and the number of elements it produces is determined by the shortest sequence\n\n::: {.cell execution_count=70}\n``` {.python .cell-code}\nseq3 = [False, True]\n\nlist(zip(seq1, seq2, seq3))\n```\n\n::: {.cell-output .cell-output-display execution_count=70}\n```\n[('foo', 'one', False), ('bar', 'two', True)]\n```\n:::\n:::\n\n\nA common use of `zip` is simultaneously iterating over multiple sequences, possibly also combined with `enumerate`\n\n::: {.cell execution_count=71}\n``` {.python .cell-code}\nfor index, (a, b) in enumerate(zip(seq1, seq2)):\n    print(f\"{index}: {a}, {b}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0: foo, one\n1: bar, two\n2: baz, three\n```\n:::\n:::\n\n\n`reversed` iterates over the elements of a sequence in reverse order\n\n::: {.cell execution_count=72}\n``` {.python .cell-code}\nlist(reversed(range(10)))\n```\n\n::: {.cell-output .cell-output-display execution_count=72}\n```\n[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n```\n:::\n:::\n\n\n## List, Set, and Dictionary Comprehensions\n\n```\n[expr for value in collection if condition]\n```\n\nFor example, given a list of strings, we could filter out strings with length 2 or less and convert them to uppercase like this\n\n::: {.cell execution_count=73}\n``` {.python .cell-code}\nstrings = [\"a\", \"as\", \"bat\", \"car\", \"dove\", \"python\"]\n\n[x.upper() for x in strings if len(x) > 2]\n```\n\n::: {.cell-output .cell-output-display execution_count=73}\n```\n['BAT', 'CAR', 'DOVE', 'PYTHON']\n```\n:::\n:::\n\n\nA dictionary comprehension looks like this\n\n```\ndict_comp = {key-expr: value-expr for value in collection\n             if condition}\n```\n\nSuppose we wanted a set containing just the lengths of the strings contained in the collection\n\n::: {.cell execution_count=74}\n``` {.python .cell-code}\nunique_lengths = {len(x) for x in strings}\n\nunique_lengths\n```\n\n::: {.cell-output .cell-output-display execution_count=74}\n```\n{1, 2, 3, 4, 6}\n```\n:::\n:::\n\n\nwe could create a lookup map of these strings for their locations in the list\n\n::: {.cell execution_count=75}\n``` {.python .cell-code}\nloc_mapping = {value: index for index, value in enumerate(strings)}\n\nloc_mapping\n```\n\n::: {.cell-output .cell-output-display execution_count=75}\n```\n{'a': 0, 'as': 1, 'bat': 2, 'car': 3, 'dove': 4, 'python': 5}\n```\n:::\n:::\n\n\n## Nested list comprehensions\n\nSuppose we have a list of lists containing some English and Spanish names. We want to get a single list containing all names with two or more a’s in them\n\n::: {.cell execution_count=76}\n``` {.python .cell-code}\nall_data = [[\"John\", \"Emily\", \"Michael\", \"Mary\", \"Steven\"],\n            [\"Maria\", \"Juan\", \"Javier\", \"Natalia\", \"Pilar\"]]\n\nresult = [name for names in all_data for name in names\n          if name.count(\"a\") >= 2]\n\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=76}\n```\n['Maria', 'Natalia']\n```\n:::\n:::\n\n\nHere is another example where we “flatten” a list of tuples of integers into a simple list of integers\n\n::: {.cell execution_count=77}\n``` {.python .cell-code}\nsome_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\n\nflattened = [x for tup in some_tuples for x in tup]\n\nflattened\n```\n\n::: {.cell-output .cell-output-display execution_count=77}\n```\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n:::\n:::\n\n\n# Functions\n\n![](https://miro.medium.com/max/1200/1*ZegxhR33NdeVRpBPYXnYYQ.gif)\n\n`Functions` are the primary and most important method of code organization and reuse in Python.\n\nthey use the `def` keyword\n\nEach function can have positional arguments and keyword arguments. Keyword arguments are most commonly used to specify default values or optional arguments. Here we will define a function with an optional z argument with the default value 1.5\n\n::: {.cell execution_count=78}\n``` {.python .cell-code}\ndef my_function(x, y, z=1.5):\n    return (x + y) * z \n\nmy_function(4,25)\n```\n\n::: {.cell-output .cell-output-display execution_count=78}\n```\n43.5\n```\n:::\n:::\n\n\nThe main restriction on function arguments is that the keyword arguments must follow the positional arguments\n\n## Namespaces, Scope, and Local Functions\n\nA more descriptive name describing a variable scope in Python is a namespace.\n\nConsider the following function\n\n::: {.cell execution_count=79}\n``` {.python .cell-code}\na = []\n\ndef func():\n    for i in range(5):\n        a.append(i)\n```\n:::\n\n\nWhen `func()` is called, the empty list a is created, five elements are appended, and then a is destroyed when the function exits. \n\n::: {.cell execution_count=80}\n``` {.python .cell-code}\nfunc()\n\nfunc()\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=80}\n```\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n```\n:::\n:::\n\n\n## Returing Multiple Values\n\nWhat’s happening here is that the function is actually just returning one object, a tuple, which is then being unpacked into the result variables.\n\n::: {.cell execution_count=81}\n``` {.python .cell-code}\ndef f():\n    a = 5\n    b = 6\n    c = 7\n    return a, b, c\n\na, b, c = f()\n\na\n```\n\n::: {.cell-output .cell-output-display execution_count=81}\n```\n5\n```\n:::\n:::\n\n\n## Functions are Objects\n\n Suppose we were doing some data cleaning and needed to apply a bunch of transformations to the following list of strings:\n\n::: {.cell execution_count=82}\n``` {.python .cell-code}\nstates = [\"   Alabama \", \"Georgia!\", \"Georgia\", \"georgia\", \"FlOrIda\",\n          \"south   carolina##\", \"West virginia?\"]\n\nimport re\n\ndef clean_strings(strings):\n    result = []\n    for value in strings:\n        value = value.strip()\n        value = re.sub(\"[!#?]\", \"\", value)\n        value = value.title()\n        result.append(value)\n    return result\n\nclean_strings(states)\n```\n\n::: {.cell-output .cell-output-display execution_count=82}\n```\n['Alabama',\n 'Georgia',\n 'Georgia',\n 'Georgia',\n 'Florida',\n 'South   Carolina',\n 'West Virginia']\n```\n:::\n:::\n\n\nAnother approach\n\n::: {.cell execution_count=83}\n``` {.python .cell-code}\ndef remove_punctuation(value):\n    return re.sub(\"[!#?]\", \"\", value)\n\nclean_ops = [str.strip, remove_punctuation, str.title]\n\ndef clean_strings(strings, ops):\n    result = []\n    for value in strings:\n        for func in ops:\n            value = func(value)\n        result.append(value)\n    return result\n\nclean_strings(states, clean_ops)\n```\n\n::: {.cell-output .cell-output-display execution_count=83}\n```\n['Alabama',\n 'Georgia',\n 'Georgia',\n 'Georgia',\n 'Florida',\n 'South   Carolina',\n 'West Virginia']\n```\n:::\n:::\n\n\nYou can use functions as arguments to other functions like the built-in `map` function\n\n::: {.cell execution_count=84}\n``` {.python .cell-code}\nfor x in map(remove_punctuation, states):\n    print(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Alabama \nGeorgia\nGeorgia\ngeorgia\nFlOrIda\nsouth   carolina\nWest virginia\n```\n:::\n:::\n\n\n## Anonymous Lambda Functions\n\n a way of writing functions consisting of a single statement\n\nsuppose you wanted to sort a collection of strings by the number of distinct letters in each string\n\n::: {.cell execution_count=85}\n``` {.python .cell-code}\nstrings = [\"foo\", \"card\", \"bar\", \"aaaaaaa\", \"ababdo\"]\n\nstrings.sort(key=lambda x: len(set(x)))\n\nstrings\n```\n\n::: {.cell-output .cell-output-display execution_count=85}\n```\n['aaaaaaa', 'foo', 'bar', 'card', 'ababdo']\n```\n:::\n:::\n\n\n# Generators\n\nMany objects in Python support iteration, such as over objects in a list or lines in a file. \n\n::: {.cell execution_count=86}\n``` {.python .cell-code}\nsome_dict = {\"a\": 1, \"b\": 2, \"c\": 3}\n\nfor key in some_dict:\n    print(key)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na\nb\nc\n```\n:::\n:::\n\n\nMost methods expecting a list or list-like object will also accept any iterable object. This includes built-in methods such as `min`, `max`, and `sum`, and type constructors like `list` and `tuple`\n\nA `generator` is a convenient way, similar to writing a normal function, to construct a new iterable object. Whereas normal functions execute and return a single result at a time, generators can return a sequence of multiple values by pausing and resuming execution each time the generator is used. To create a generator, use the yield keyword instead of return in a function\n\n::: {.cell execution_count=87}\n``` {.python .cell-code}\ndef squares(n=10):\n    print(f\"Generating squares from 1 to {n ** 2}\")\n    for i in range(1, n + 1):\n        yield i ** 2\n\ngen = squares()\n\nfor x in gen:\n    print(x, end=\" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGenerating squares from 1 to 100\n1 4 9 16 25 36 49 64 81 100 \n```\n:::\n:::\n\n\n> Since generators produce output one element at a time versus an entire list all at once, it can help your program use less memory.\n\n## Generator expressions\n\n This is a generator analogue to list, dictionary, and set comprehensions. To create one, enclose what would otherwise be a list comprehension within parentheses instead of brackets:\n\n::: {.cell execution_count=88}\n``` {.python .cell-code}\ngen = (x ** 2 for x in range(100))\n\ngen\n```\n\n::: {.cell-output .cell-output-display execution_count=88}\n```\n<generator object <genexpr> at 0x000001E3C1E4FD60>\n```\n:::\n:::\n\n\nGenerator expressions can be used instead of list comprehensions as function arguments in some cases:\n\n::: {.cell execution_count=89}\n``` {.python .cell-code}\nsum(x ** 2 for x in range(100))\n```\n\n::: {.cell-output .cell-output-display execution_count=89}\n```\n328350\n```\n:::\n:::\n\n\n::: {.cell execution_count=90}\n``` {.python .cell-code}\ndict((i, i ** 2) for i in range(5))\n```\n\n::: {.cell-output .cell-output-display execution_count=90}\n```\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n```\n:::\n:::\n\n\n## itertools module\n\n`itertools` module has a collection of generators for many common data algorithms.\n\n`groupby` takes any sequence and a function, grouping consecutive elements in the sequence by return value of the function\n\n::: {.cell execution_count=91}\n``` {.python .cell-code}\nimport itertools\n\ndef first_letter(x):\n    return x[0]\n\nnames = [\"Alan\", \"Adam\", \"Jackie\", \"Lily\", \"Katie\", \"Molly\"]\n\nfor letter, names in itertools.groupby(names, first_letter):\n    print(letter, list(names))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nA ['Alan', 'Adam']\nJ ['Jackie']\nL ['Lily']\nK ['Katie']\nM ['Molly']\n```\n:::\n:::\n\n\n[Table of other itertools functions](https://wesmckinney.com/book/python-builtin.html#tbl-table_itertools)\n\n# Errors and Exception Handling\n\nHandling errors or exceptions gracefully is an important part of building robust programs\n\n::: {.cell execution_count=92}\n``` {.python .cell-code}\ndef attempt_float(x):\n    try:\n        return float(x)\n    except:\n        return x\n\nattempt_float(\"1.2345\")\n```\n\n::: {.cell-output .cell-output-display execution_count=92}\n```\n1.2345\n```\n:::\n:::\n\n\n::: {.cell execution_count=93}\n``` {.python .cell-code}\nattempt_float(\"something\")\n```\n\n::: {.cell-output .cell-output-display execution_count=93}\n```\n'something'\n```\n:::\n:::\n\n\nYou might want to suppress only ValueError, since a TypeError (the input was not a string or numeric value) might indicate a legitimate bug in your program. To do that, write the exception type after except:\n\n::: {.cell execution_count=94}\n``` {.python .cell-code}\ndef attempt_float(x):\n    try:\n        return float(x)\n    except ValueError:\n        return x\n```\n:::\n\n\n::: {.cell execution_count=95}\n``` {.python .cell-code}\nattempt_float((1, 2))\n```\n:::\n\n\n```\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nd:\\packages\\bookclub-py4da\\03_notes.qmd in <cell line: 1>()\n----> 1001 attempt_float((1, 2))\n\nInput In [114], in attempt_float(x)\n      1 def attempt_float(x):\n      2     try:\n----> 3         return float(x)\n      4     except ValueError:\n      5         return x\n\nTypeError: float() argument must be a string or a real number, not 'tuple'\n\n```\n\nYou can catch multiple exception types by writing a tuple of exception types instead (the parentheses are required):\n\n::: {.cell execution_count=96}\n``` {.python .cell-code}\ndef attempt_float(x):\n    try:\n        return float(x)\n    except (TypeError, ValueError):\n        return x\n\nattempt_float((1, 2))\n```\n\n::: {.cell-output .cell-output-display execution_count=95}\n```\n(1, 2)\n```\n:::\n:::\n\n\nIn some cases, you may not want to suppress an exception, but you want some code to be executed regardless of whether or not the code in the try block succeeds. To do this, use `finally`:\n\n::: {.cell execution_count=97}\n``` {.python .cell-code}\nf = open(path, mode=\"w\")\n\ntry:\n    write_to_file(f)\nfinally:\n    f.close()\n```\n:::\n\n\nHere, the file object f will always get closed. \n\nyou can have code that executes only if the try: block succeeds using else:\n\n::: {.cell execution_count=98}\n``` {.python .cell-code}\nf = open(path, mode=\"w\")\n\ntry:\n    write_to_file(f)\nexcept:\n    print(\"Failed\")\nelse:\n    print(\"Succeeded\")\nfinally:\n    f.close()\n```\n:::\n\n\n## Exceptions in IPython\n\nIf an exception is raised while you are %run-ing a script or executing any statement, IPython will by default print a full call stack trace. Having additional context by itself is a big advantage over the standard Python interpreter\n\n# Files and the Operating System\n\nTo open a file for reading or writing, use the built-in open function with either a relative or absolute file path and an optional file encoding.\n\nWe can then treat the file object f like a list and iterate over the lines\n\n::: {.cell execution_count=99}\n``` {.python .cell-code}\npath = \"examples/segismundo.txt\"\n\nf = open(path, encoding=\"utf-8\")\n\nlines = [x.rstrip() for x in open(path, encoding=\"utf-8\")]\n\nlines\n```\n:::\n\n\nWhen you use open to create file objects, it is recommended to close the file\n\n::: {.cell execution_count=100}\n``` {.python .cell-code}\nf.close()\n```\n:::\n\n\nsome of the most commonly used methods are `read`, `seek`, and `tell`.\n\n`read(10)` returns 10 characters from the file\n\nthe `read` method advances the file object position by the number of bytes read\n\n`tell()` gives you the current position in the file\n\nTo get consistent behavior across platforms, it is best to pass an encoding (such as `encoding=\"utf-8\"`)\n\n`seek(3)` changes the file position to the indicated byte \n\nTo write text to a file, you can use the file’s `write` or `writelines` methods\n\n## Byte and Unicode with Files\n\nThe default behavior for Python files (whether readable or writable) is text mode, which means that you intend to work with Python strings (i.e., Unicode). \n\n",
    "supporting": [
      "03_notes_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}